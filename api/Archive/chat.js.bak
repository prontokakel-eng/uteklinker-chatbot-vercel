// /api/chat.js
import fs from "fs";
import path from "path";
import OpenAI from "openai";
import stringSimilarity from "string-similarity";
import { getFaqCache } from "./../lib/faq-cache.js";
import { containsAllowedWord, detectLangLocal } from "./../lib/utils.js";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Loggfil i /logs
const LOG_FILE = path.join(process.cwd(), "logs", "dev-chat.log");
function logToFile(msg) {
  const line = `[${new Date().toISOString()}] ${msg}\n`;
  fs.appendFileSync(LOG_FILE, line, "utf8");
}

function notRelatedMessage(lang = "SE") {
  const msgs = {
    SE: "⚠️ Din fråga verkar inte relatera till våra produkter. Vänligen omformulera din fråga.",
    EN: "⚠️ Your question doesn’t seem related to our products. Please rephrase your question.",
    DA: "⚠️ Dit spørgsmål ser ikke ud til at vedrøre vores produkter. Venligst omformuler dit spørgsmål.",
    DE: "⚠️ Ihre Frage scheint sich nicht auf unsere Produkte zu beziehen. Bitte formulieren Sie die Frage neu.",
  };
  return msgs[lang] || msgs.SE;
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    res.setHeader("Allow", ["POST"]);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  try {
    let body = req.body;
    if (typeof body === "string") {
      try {
        body = JSON.parse(body);
      } catch {
        return res.status(400).json({ success: false, error: "Invalid JSON" });
      }
    }

    let { text } = body || {};
    if (!text) {
      return res.status(400).json({ success: false, error: "Missing text" });
    }

    // 🚀 Alltid använd detectLangLocal
    const { lang: detectedLang, method } = detectLangLocal(text);
    let finalLang = detectedLang;

    // Säker fallback → SE
    if (!["SE", "EN", "DA", "DE"].includes(finalLang)) {
      logToFile(`⚠️ Lang fallback → SE | Input="${text}"`);
      finalLang = "SE";
    }
    logToFile(`🌍 Lang detect → ${detectedLang} via ${method} | Using=${finalLang} | Input="${text}"`);

    // 🚧 Allowed-words gate
    if (!containsAllowedWord(text, finalLang)) {
      logToFile(`FILTER → Not related (${finalLang}) | Input="${text}"`);
      return res.status(200).json({
        success: true,
        reply: notRelatedMessage(finalLang),
        score: 1,
        source: "FILTER",
      });
    }

    // --- FAQ-matchning ---
    const FAQ_CACHE = await getFaqCache();
    const faqs = FAQ_CACHE?.[finalLang] || [];
    logToFile(`📚 FAQ-cache | Lang=${finalLang} | Count=${faqs.length}`);

    let bestMatch = null;

    if (faqs.length > 0) {
      const questions = faqs.map((f) => f.question);
      const matches = stringSimilarity.findBestMatch(text, questions);
      if (matches.bestMatch.rating > 0.6) {
        bestMatch = {
          reply: faqs[matches.bestMatchIndex].answer,
          score: matches.bestMatch.rating,
          source: "FAQ_" + finalLang,
        };
        logToFile(`FAQ HIT (${finalLang}) | Q="${faqs[matches.bestMatchIndex].question}" | Score=${matches.bestMatch.rating}`);
      }
    }

    // --- AI fallback ---
    if (!bestMatch) {
      logToFile(`AI fallback (${finalLang}) | Input="${text}"`);
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "system", content: "Du är en FAQ-bot för Uteklinker." },
          { role: "user", content: text },
        ],
        max_tokens: 300,
      });

      bestMatch = {
        reply: response.choices[0]?.message?.content?.trim() || "(no answer)",
        score: 1,
        source: "AI",
      };
    }

    logToFile(`FINAL (${finalLang}) | Source=${bestMatch.source} | Reply="${bestMatch.reply.slice(0, 80)}..."`);

    return res.status(200).json({ success: true, ...bestMatch });
  } catch (err) {
    console.error("💥 chat error:", err);
    logToFile(`💥 chat error: ${err.message}`);
    return res.status(500).json({
      success: false,
      error: err.message || "Unexpected server error",
    });
  }
}
